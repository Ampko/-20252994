# 오픈소스SW개론 [과제2] README 파일 작성하기
##김의빈 20252994
> **top, ps, jobs, kill** 명령어

---

## 목차

1. [top 명령어](#-top-명령어)
2. [ps 명령어](#-ps-명령어)
3. [jobs 명령어](#-jobs-명령어)
4. [kill 명령어](#-kill-명령어)
5. [명령어 비교표](#-명령어-비교표)
6. [요약 및 팁](#-요약-및-팁)

---

## top 명령어

### 개요

`top` 명령어는 시스템의 프로세스와 리소스 사용 현황을 **실시간으로 모니터링**하는 가장 강력한 도구입니다.
Unix/Linux 시스템 관리자와 개발자들이 가장 자주 사용하는 명령어 중 하나입니다.

### 기본 문법

```bash
top [옵션]
```

### 주요 옵션

| 옵션 | 설명 | 예시 |
|:---:|------|------|
| `-u [사용자명]` | 특정 사용자의 프로세스만 표시 | `top -u root` |
| `-p [PID]` | 특정 PID의 프로세스만 모니터링 | `top -p 1234` |
| `-n [숫자]` | 지정된 횟수만큼 업데이트 후 종료 | `top -n 5` |
| `-d [초]` | 업데이트 간격 설정 | `top -d 2` |
| `-b` | 배치 모드 (비대화형 모드) | `top -b` |
| `-H` | 스레드 정보 표시 | `top -H` |

### top 화면의 주요 정보

```
top - 14:32:45 up 2 days,  3:12,  2 users,  load average: 0.15, 0.18, 0.12
Tasks: 185 total,   2 running, 183 sleeping,   0 stopped,   0 zombie
%Cpu(s):  5.2 us,  2.1 sy,  0.0 ni, 92.4 id,  0.2 wa,  0.0 hi,  0.1 si,  0.0 st
MiB Mem :   7956.4 total,   3521.2 free,   2124.6 used,   2310.6 buff/cache
MiB Swap:   2048.0 total,   2048.0 free,      0.0 used.   5138.2 avail Mem

  PID USER      PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND
```

**필드 설명:**
- **PID**: 프로세스 ID 번호
- **USER**: 프로세스를 실행한 사용자명
- **%CPU**: CPU 사용률 (%)
- **%MEM**: 메모리 사용률 (%)
- **VIRT**: 가상 메모리 사용량 (KB)
- **RES**: 실제 메모리 사용량 (KB)
- **STAT**: 프로세스 상태
  - `R`: Running (실행 중)
  - `S`: Sleeping (슬립 상태)
  - `Z`: Zombie (좀비 프로세스)
  - `T`: Stopped (정지됨)

### 사용 예제

```bash
# 기본 실행 (실시간 모니터링)
$ top

# 특정 사용자(root)의 프로세스만 표시
$ top -u root

# 5초 간격으로 3번만 업데이트하고 종료
$ top -n 3 -d 5

# PID 1234인 프로세스만 모니터링
$ top -p 1234

# 배치 모드로 현재 상태만 한 번 출력
$ top -b -n 1
```

---

## ps 명령어

### 개요

`ps`는 **현재 실행 중인 프로세스의 스냅샷**을 보여주는 명령어입니다. 
top과 달리 실시간이 아닌 정적인 정보를 제공하므로 특정 시점의 프로세스 상태를 빠르게 확인할 때 유용합니다.

### 기본 문법

```bash
ps [옵션]
```

### 주요 옵션

| 옵션 | 설명 | 예시 |
|:---:|------|------|
| `a` | 모든 사용자의 프로세스 표시 | `ps a` |
| `u` | 사용자 이름, CPU, 메모리 등 상세 정보 | `ps u` |
| `x` | 제어 터미널이 없는 프로세스도 표시 | `ps x` |
| `f` | 프로세스 계층 구조를 **트리 형태**로 표시 | `ps f` |
| `-e` | 모든 프로세스 표시 | `ps -e` |
| `-o [포맷]` | 출력 형식 사용자 지정 | `ps -o pid,user,cmd` |
| `-C [명령어]` | 특정 명령어 이름으로 검색 | `ps -C bash` |

### ps 명령어 출력 화면

![ps aux 명령어 실행 화면](이미지 경로 입력)

> ps aux 명령어로 조회한 전체 프로세스 목록입니다. 각 열은 PID, USER, CPU, MEM, COMMAND 등의 정보를 나타냅니다.

---

## jobs 명령어

### 개요

`jobs`는 **현재 셸(shell) 세션에서 실행 중인** 백그라운드 및 포그라운드 작업의 상태를 표시하는 명령어입니다.
주의: 다른 터미널이나 다른 셸의 작업은 표시되지 않습니다.

### 기본 문법

```bash
jobs [옵션]
```

### 주요 옵션

| 옵션 | 설명 |
|:---:|------|
| `-l` | 프로세스 ID(PID)와 함께 표시 |
| `-p` | 프로세스 ID만 표시 |
| `-r` | **Running** 상태의 작업만 표시 |
| `-s` | **Stopped** 상태의 작업만 표시 |
| `-n` | 마지막 상태가 변경된 작업만 표시 |

### 작업 상태

| 상태 | 설명 |
|:---:|------|
| **Running** | 현재 실행 중인 상태 |
| **Stopped** | Ctrl+Z로 일시정지된 상태 |
| **Done** | 작업이 성공적으로 완료됨 |
| **Terminated** | 강제 종료됨 |

### 작업 제어 명령어

```bash
# 백그라운드 작업을 포그라운드로 전환
$ fg %1

# 포그라운드 작업을 백그라운드에서 계속 실행
$ bg %1

# 작업 강제 종료 (셸 내부 명령)
$ kill %1
```

### jobs 명령어 출력 화면

![jobs 명령어 실행 화면](이미지 경로 입력)

> 현재 셸에서 실행 중인 백그라운드 및 포그라운드 작업들을 표시합니다.

---

## kill 명령어

### 개요

`kill` 명령어는 프로세스에 **신호(signal)**를 전송하여 프로세스의 동작을 제어하는 명령어입니다.
단순히 "종료"만 하는 것이 아니라, 다양한 신호를 통해 프로세스와 통신합니다.

### 기본 문법

```bash
kill [신호] [PID]
kill -l              # 사용 가능한 모든 신호 목록 확인
```

### 주요 신호(Signal)

| 신호명 | 번호 | 약자 | 설명 | 사용 시기 |
|:---:|:---:|:---:|------|---------|
| SIGHUP | 1 | HUP | 터미널 연결 끊김 | 설정 파일 다시 읽기 |
| SIGINT | 2 | INT | 인터럽트 (Ctrl+C) | 대화형 프로세스 중단 |
| SIGQUIT | 3 | QUIT | 종료 (Ctrl+\\) | 코어 덤프 생성 |
| SIGKILL | 9 | KILL | **강제 종료** | 마지막 수단 |
| SIGTERM | 15 | TERM | 정상 종료 (기본값) | 프로세스 정상 종료 |
| SIGSTOP | 19 | STOP | 일시정지 | 프로세스 중단 |
| SIGCONT | 18 | CONT | 재개 | 일시정지된 프로세스 재개 |
| SIGKILL | 9 | KILL | 강제 종료 | 종료 불가능한 프로세스 |

### kill 신호 흐름도

![프로세스 종료 흐름도 - SIGTERM에서 SIGKILL로](이미지 경로 입력)

> 프로세스 종료 시 권장되는 신호 순서: SIGTERM(15) → SIGKILL(9)

### 사용 예제

```bash
# 정상 종료 요청 (권장 방법)
$ kill 1234
$ kill -15 1234
$ kill -SIGTERM 1234

# 강제 종료 (정상 종료가 안 될 때만 사용)
$ kill -9 1234
$ kill -SIGKILL 1234

# 프로세스 일시정지
$ kill -STOP 1234
$ kill -19 1234

# 일시정지된 프로세스 재개
$ kill -CONT 1234
$ kill -18 1234

# 프로세스명으로 종료 (killall 명령어 사용)
$ killall python
$ killall -9 chrome

# 모든 신호 목록 확인
$ kill -l

# 특정 사용자의 모든 프로세스 종료
$ killall -u username
```

---

## 명령어 비교표

| 구분 | **top** | **ps** | **jobs** | **kill** |
|:---:|:---:|:---:|:---:|:---:|
| **기능** | 실시간 모니터링 | 스냅샷 조회 | 작업 상태 확인 | 신호 전송 |
| **출력 방식** | 계속 업데이트 | 한 번만 출력 | 한 번만 출력 | 신호 전송 |
| **범위** | 전체 시스템 | 전체 시스템 | 현재 셸만 | 지정 프로세스 |
| **속도** | 느림 | 빠름 | 매우 빠름 | 빠름 |
| **CPU 사용률** | 높음 | 낮음 | 낮음 | 없음 |
| **사용 목적** | 지속적 모니터링 | 현황 파악 | 백그라운드 작업 | 프로세스 제어 |
| **종료 방법** | `q` 키 입력 | 자동 종료 | 자동 종료 | 즉시 실행 |

---

## 요약 및 팁

### 명령어 선택 기준

- **실시간 지속 모니터링** → `top` 사용
- **빠른 현황 파악** → `ps aux` 사용
- **백그라운드 작업 관리** → `jobs` 사용
- **프로세스 제어/종료** → `kill` 사용

### 주의사항

- **root 권한**: 다른 사용자의 프로세스는 root 권한으로만 종료 가능
- **SIGKILL(-9) 사용**: 마지막 수단으로만 사용! (자원 정리 불가)
- **jobs 범위**: 현재 셸 세션의 작업만 표시 (다른 터미널 작업 미포함)
- **성능**: top은 CPU를 많이 사용하므로 필요할 때만 사용

### 유용한 팁

```bash
# 모든 프로세스를 트리 구조로 보기 (가장 유용!)
$ ps auxf

# 특정 프로세스와 자식 프로세스 모두 종료
$ kill -9 $(pgrep -P [PID])

# 프로세스명으로 PID 찾기
$ pgrep python

# 프로세스 상태를 CSV 형식으로 저장
$ ps aux > process_status.csv

# top 결과를 파일로 저장
$ top -b -n 1 > top_output.txt
```

### 매뉴얼 확인

모든 명령어의 상세한 매뉴얼을 확인할 수 있습니다:

```bash
$ man top
$ man ps
$ man jobs
$ man kill
```

---

## 참고 자료

- [Linux man pages online](https://man7.org/linux/man-pages/)
- [GNU Coreutils](https://www.gnu.org/software/coreutils/)
- [Linux System Administration](https://tldp.org/)

---

<div align="center">

</div>
